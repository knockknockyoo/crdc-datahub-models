name: Update Data Model Version
on:
  schedule:
    - cron: "29 * * * *"   # every hour on 29th minute, randomly chose
  workflow_dispatch:

jobs:
  update-data-model-version:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - branch-name: master
            tag_enabled: false
    #          - branch-name: dev2
    #            tag_enabled: false
    #          - branch-name: qa
    #            tag_enabled: false
    #          - branch-name: qa2
    #            tag_enabled: false
    #          - branch-name: stage
    #            tag_enabled: true  # Enables tag checkout for this branch
    #          - branch-name: prod
    #            tag_enabled: true # Enables tag checkout for this branch
    steps:
      - name: Printing the branch currently working on
        run: echo "BRANCH_NAME=${{ matrix.branch-name }}"
      - name: Check out the branch
        uses: actions/checkout@v3
        with:
          ref: ${{ matrix.branch-name }}
          submodules: true  # This ensures submodules are also checked out
          submodules_recursive: true  # Recursively fetches submodules
          fetch-depth: 0  # Fetch all history
      - name: Fetch all tags in the main repository
        if: matrix.tag_enabled == true
        run: |
          git fetch --tags
      - name: Check if tag_enabled is true and Determine and checkout latest tag for main repository
        if: matrix.tag_enabled == true
        run: |
          latest_tag=$(git tag -l "[0-9]*.[0-9]*.[0-9]*" | sort -V | tail -n 1)  # Get latest tag in <major>.<minor>.<patch> format
          if [ -n "$latest_tag" ]; then
            echo "Checking out latest tag $latest_tag for main repository"
            git checkout $latest_tag
          else
            echo "No valid tag found for the main repository"
          fi
      - name: Rebase latest tag onto the matrix branch
        run: |
          git checkout ${{ matrix.branch-name }}   # Switch back to the target branch (dev)
          if [ "${{ matrix.tag_enabled }}" = "true" ]; then
            git rebase $latest_tag
          fi
      - name: Update submodule to the latest commit
        run: |
          git submodule update --remote --recursive
          git submodule foreach --recursive '
            if [ "${{ matrix.tag_enabled }}" = "true" ]; then
              git fetch --tags
              latest_tag=$(git tag -l "[0-9]*.[0-9]*.[0-9]*" | sort -V | tail -n 1)  # Get the latest tag in <major>.<minor>.<patch> format
              if [ -n "$latest_tag" ]; then
                echo "Checking out latest tag $latest_tag for $name"
                git checkout $latest_tag
              else
                echo "No valid tag found for $name"
              fi
            else
              branch=$(git config -f $toplevel/.gitmodules submodule.$name.branch)
              echo "Fetching submodule branch: $branch"
              git fetch origin $branch
            fi
            git merge --allow-unrelated-histories FETCH_HEAD || echo "No merge needed"
          '
      - name: Overwrite all files from the submodule
        run: |
          # get the latest version from the cache and overwrite all files
          # pass if the no version in the cache; meaning never run github action
          content=$(cat cache/content.json)
          to_be_updated=""
          echo "$content" | jq -r 'to_entries[] | "\(.key)"' | while read key; do          
            # store models in the env              
            CACHE_DIR="cache/$key"
            largest_version_folder=$(ls -1 "$CACHE_DIR" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n 1)
            echo "Largest semantic version folder: $largest_version_folder"            
            # The path containing files must be a model-desc
            model_prefix=$(echo "${key}-model" | tr 'A-Z' 'a-z')
            model_path="$model_prefix/model-desc"
          
            target_folder="cache/$key/$largest_version_folder/"
            if [ -d "$target_folder" ]; then
              echo "copying files....$target_folder"
              cp -r "$model_path/"* "$target_folder"
              git add "$target_folder" # Stage changes in the target folder      
            fi
          
            # no folder has been created => never run => run!
            # latest folder has been changed => needs to be updated => run!
            if ! git diff --cached --quiet -- "$target_folder" || ([ ! -d "$target_folder" ] && [ -d "$model_path" ]); then
              echo "Detected changes: $key"
              git diff --cached -- "$target_folder" # Show detailed changes for debugging
              to_be_updated=${to_be_updated:+$to_be_updated,}$model_path
            else
              echo "No changes to commit for $key"
              git diff --cached -- "$target_folder" # Show detailed changes for debugging
            fi
          echo "end of action $to_be_updated"
          echo "updated_path=$to_be_updated" >> $GITHUB_ENV
          done
      - name: Check and create version folders
        run: |
          content=$(cat cache/content.json)
          echo "$content" | jq -r 'to_entries[] | "\(.key) \(.value["current-version"]) \(.value["model-files"]) \(.value["prop-file"])"' | while read key current_version model_files prop_file; do
            # uses a prefix path ex) cds(lowercase) + -model, icdc(lowercase) + -model
            model_prefix=$(echo "${key}-model" | tr 'A-Z' 'a-z')
            model_path="$model_prefix/model-desc"
            if [[ "${{env.updated_path}}" == *"$model_path"* ]]; then
              echo "The string $model_path is found in 'env_updated_path'."
              echo "$model_files" | jq -r '.[]' | while read -r model_file; do
                echo "This is an individual file name: $model_file"
                version_file_path="$model_path/$model_file"
                echo "$version_file_path"
                echo "test.....grep -q '^Version:' "$version_file_path"
                if [ -f "$version_file_path" ] && grep -q '^Version:' "$version_file_path"; then
                  echo "test.....$version_file_path"
                  latest_version=$(grep -i '^Version:' "$version_file_path" | sed 's/[Vv]ersion:[ vV]*//' | tr -cd '0-9.')      
                  echo "latest_version $latest_version"
                  break
                fi 
              done
            fi
          done